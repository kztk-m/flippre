{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TupleSections #-}
{-# LANGUAGE UndecidableInstances #-}

-- | Utility to handle branching. The goal of this module is to provide basic building blocks to
--   write FliPpr patterns.
--
--   For example, by this module's functions, one can write:
--
--   > case_ x [ pNil `br` ... {- nil case -} ...,
--   >           pCons varP pNil `br` \x -> ... {- singleton case -} ...,
--   >           pCons varP (pCons varP varP) `br` \x y xs -> ... {- double cons case -} ... ]
module Text.FliPpr.Pat (
  PatT,
  varP,
  lift,
  (&.),
  unit,
  toPartialBij,

  -- * Derived combinators
  lift0,
  lift2,
  lift3,

  -- * Predefined pattern-like combinators.
  pNil,
  pCons,
  pTrue,
  pFalse,

  -- * Pattern to branching
  Decomp (..),
  br,
) where

import Text.FliPpr.Internal.Type

-- Patterns as

data PBij a b = PBij !(a -> Maybe b) !(b -> Maybe a)

fromPBij :: (PBij a b, ShowS) -> PartialBij a b
fromPBij (PBij f fi, fn) = PartialBij (fn "") f fi

-- | A pattern of type @a@ transforms environments from @env@ to @env'@.
newtype PatT env env' a = PatT {runPatT :: forall r. PBij r env -> (PBij (a, r) env', ShowS)}

-- | A variable pattern of type @a@.
varP :: PatT env (a, env) a
varP = PatT $ \(PBij f fi) -> (PBij (\(a, env) -> (a,) <$> f env) (\(a, r) -> (a,) <$> fi r), showString "_")

-- | Lifting 'PartialBij' into a pattern transformer.
lift :: forall a b env env'. PartialBij a b -> PatT env env' b -> PatT env env' a
lift (PartialBij fn f fi) (PatT tr) = PatT $ h . tr
  where
    h :: (PBij (b, r) env', ShowS) -> (PBij (a, r) env', ShowS)
    h (PBij g gi, gn) =
      ( PBij (\(a, r) -> do b <- f a; g (b, r)) (\x -> do (b, r) <- gi x; a <- fi b; return (a, r))
      , showParen True (showString fn . showString " " . gn)
      )

prod :: PatT env' env'' a -> PatT env env' b -> PatT env env'' (a, b)
prod (PatT tr1) (PatT tr2) = PatT $ \p ->
  let (x, w2) = tr2 p
      (y, w1) = tr1 x
  in  (arr y, w1 . showString " " . w2)
  where
    arr :: PBij (a, (b, r)) env'' -> PBij ((a, b), r) env''
    arr (PBij f fi) = PBij (f . assocr) (fmap assocl . fi)

    assocr ((a, b), c) = (a, (b, c))
    assocl (a, (b, c)) = ((a, b), c)

-- | Pair patterns.
(&.) :: PatT env' env'' a -> PatT env env' b -> PatT env env'' (a, b)
(&.) = prod

infixr 4 &.

-- | The unit pattern.
unit :: PatT env env ()
unit = PatT $ \(PBij f fi) -> (PBij (\((), r) -> f r) (fmap ((),) . fi), id)

-- | Lifting of 'PartialBij' that returns @()@.
lift0 :: PartialBij a () -> PatT env' env' a
lift0 p = lift p unit

-- | Lifting of 'PartialBij' that returns pairs.
lift2 :: PartialBij a (b, c) -> PatT env'1 env'2 b -> PatT env env'1 c -> PatT env env'2 a
lift2 p x y = lift p (x &. y)

-- | Lifting of 'PartialBij' that returns triples represented as nested pair.
lift3 :: PartialBij a (b, (c, d)) -> PatT env2 env3 b -> PatT env1 env2 c -> PatT env env1 d -> PatT env env3 a
lift3 p x y z = lift p (x &. y &. z)

-- | Converts 'PatT' to 'PartialBij'
--
-- >>> :t toPartialBij (pCons varP (pCons varP varP))
-- toPartialBij (pCons varP (pCons varP varP)) :: forall b. PartialBij [b] (b, (b, ([b], ())))
-- >>> :t toPartialBij (pCons (pCons varP varP) (pCons varP varP))
-- toPartialBij (pCons (pCons varP varP) (pCons varP varP)) :: forall b. PartialBij [[b]] (b, ([b], ([b], ([[b]], ()))))
toPartialBij :: PatT () env a -> PartialBij a env
toPartialBij tr = fromPBij $ h $ runPatT tr (PBij Just Just)
  where
    h :: (PBij (a, ()) env, ShowS) -> (PBij a env, ShowS)
    h (PBij f fi, fn) = (PBij (\a -> f (a, ())) (fmap fst . fi), fn)

bNil :: PartialBij [a] ()
bNil = PartialBij "[]" (\case [] -> Just (); _ -> Nothing) (const $ Just [])

bTrue :: PartialBij Bool ()
bTrue = PartialBij "True" (\case True -> Just (); _ -> Nothing) (const $ Just True)

bFalse :: PartialBij Bool ()
bFalse = PartialBij "False" (\case False -> Just (); _ -> Nothing) (const $ Just False)

-- | A pattern corresponding to @[]@
pNil :: PatT env env [a]
pNil = lift0 bNil

bCons :: PartialBij [a] (a, [a])
bCons = PartialBij "(:)" (\case a : x -> Just (a, x); _ -> Nothing) (Just . uncurry (:))

-- | A pattern corresponding to '(:)'
pCons :: PatT env'1 env'2 b -> PatT env env'1 [b] -> PatT env env'2 [b]
pCons = lift2 bCons

-- | A pattern corresponding to 'True'
pTrue :: PatT env' env' Bool
pTrue = lift0 bTrue

-- | A pattern corresponding to 'False'
pFalse :: PatT env' env' Bool
pFalse = lift0 bFalse

-- | General decomposer. It assumes that an input is a right-nested pair, as @e :: A arg (a1, (a2, ())@.
--   Then, it can decompose as
--   @
--   decomp e $ \a1 a2 -> ...
--   @
--
--   Notice that tip must be @()@ to use this function, as those generated by 'pat'.
class (FliPprE arg exp) => Decomp arg exp a r t | r -> t exp arg, exp -> arg, exp a t -> r where
  decomp :: A arg a -> r -> E exp t

instance (FliPprE arg exp) => Decomp arg exp () (E exp t) t where
  decomp = ununit

instance (Decomp arg exp as r t) => Decomp arg exp (a, as) (A arg a -> r) t where
  decomp as f = unpair as $ \a1 a2 -> decomp a2 $ f a1

-- | 'br' combines 'Branch', 'pat' and 'decomp'.
--
--   prop> br p k = Branch (pat p) $ \a -> decomp a k
br :: (Decomp arg exp b r t) => PatT () b a -> r -> Branch (A arg) (E exp) a t
br p k = Branch (toPartialBij p) $ \a -> decomp a k
